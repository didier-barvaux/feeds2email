#!/bin/bash
#
# Copyright (c) 2015 Didier Barvaux
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

#
# Name:         feeds2email
# Description:  fetch RSS, Atom or RDF feeds and send new articles by email
# Dependencies: bash, curl, xmlstarlet, Python html2text, logger, md5sum, awk,
#               sed, tr, find, grep, mail, and mktemp.
# Author:       Didier Barvaux <didier@barvaux.org>
# License:      Simplified BSD License
#
# Thanks to thuban <thuban@yeuxdelibad.net> and his srss software for the ideas:
#   http://git.yeuxdelibad.net/srss/
#

SCRIPT_NAME="feeds2email"
SCRIPT_VERSION="0.1"
SCRIPT_URI="https://github.com/didier-barvaux/${SCRIPT_NAME}"

F2E_CONFIG_DIR="${HOME}/.config/${SCRIPT_NAME}"
F2E_CACHE_DIR="${HOME}/.cache/${SCRIPT_NAME}"

F2E_LOG_FACILITY="local1"
F2E_NETWORK_TRIES=2
F2E_NETWORK_TIMEOUT=30 # in seconds
F2E_NETWORK_MAX_FILE_SIZE=$(( 1 * 1024 * 1024 )) # 1 MByte
F2E_USER_AGENT="${SCRIPT_NAME}/${SCRIPT_VERSION} (${SCRIPT_URI})"

F2E_FEEDLIST_FILE="${F2E_CONFIG_DIR}/feedlist" # one feed url per line
F2E_FEEDS_DIR="${F2E_CACHE_DIR}/feeds"

SEP_ITEMS="---item---"
SEP_FIELDS="---field---"


f2e_print_usage()
{
	echo "Send news feeds by email"
	echo ""
	echo "Fetch all RSS, Atom or RDF feeds listed in \$HOME/.config/${SCRIPT_NAME}/feedlist"
	echo "and send new articles to the given email. Feeds are recorded in the"
	echo "\$HOME/.cache/${SCRIPT_NAME}/ cache directory."
	echo ""
	echo "Usage: ${SCRIPT_NAME} [options] config"
	echo "       ${SCRIPT_NAME} [options] config email-to   [<email>]"
	echo "       ${SCRIPT_NAME} [options] config email-from [<email>]"
	echo "       ${SCRIPT_NAME} [options] config fake-user-agent [<string>]"
	echo "       ${SCRIPT_NAME} [options] list"
	echo "       ${SCRIPT_NAME} [options] status  [<feed-uri>]"
	echo "       ${SCRIPT_NAME} [options] add     <feed-uri> [<flag>[,<flag>...]]"
	echo "       ${SCRIPT_NAME} [options] del     <feed-uri>"
	echo "       ${SCRIPT_NAME} [options] enable  <feed-uri>"
	echo "       ${SCRIPT_NAME} [options] disable <feed-uri>"
	echo "       ${SCRIPT_NAME} [options] update  <feed-uri>"
	echo "       ${SCRIPT_NAME} [options] update"
	echo ""
	echo "Commands:"
	echo "  config             Print/set the configuration"
	echo "  list               List the registered feeds"
	echo "  add                Register a new feed (and enable it)"
	echo "  del                Unregister an existing feed"
	echo "  status             Print the status of feeds in error or of an existing feed"
	echo "  enable             Enable a new feed"
	echo "  disable            Disable an existing feed"
	echo "  update             Retrieve, parse and send new articles for all"
	echo "                       registered feeds or the specified one"
	echo ""
	echo "Configuration attributes:"
	echo "  email-to           Print/configure the name and email address of the user"
	echo "  email-from         Print/configure the sender email address"
	echo "  fake-user-agent    Print/configure the fake user agent for download"
	echo "                       (only apply to feeds with the fake-user-agent flag)"
	echo ""
	echo "Feed flags:"
	echo "  fake-user-agent    Fake the HTTP User-Agent for this feed"
	echo "                       (config attribute fake-user-agent shall be set)"
	echo ""
	echo "Options:"
	echo "  email          An email address"
	echo "  feed-uri       The URI of the feed"
	echo "  -h, --help     Print this help message"
	echo "  -q, --quiet    Run in quiet mode"
	echo "  -v, --version  Print software version and quit"
	echo ""
	echo "Examples:"
	echo "  ${SCRIPT_NAME} --help                                                       Print software usage"
	echo "  ${SCRIPT_NAME} --version                                                    Print software version"
	echo "  ${SCRIPT_NAME} list                                                         List registered feeds"
	echo "  ${SCRIPT_NAME} add https://github.com/didier-barvaux/feeds2email/commits/master.atom      Register a new feed"
	echo "  ${SCRIPT_NAME} disable https://github.com/didier-barvaux/feeds2email/commits/master.atom  Disable a feed"
	echo "  ${SCRIPT_NAME} enable https://github.com/didier-barvaux/feeds2email/commits/master.atom   Enable a new feed"
	echo "  ${SCRIPT_NAME} del https://github.com/didier-barvaux/feeds2email/commits/master.atom      Unregister a new feed"
	echo "  ${SCRIPT_NAME} john.snow@example.com ${SCRIPT_NAME}@example.com                Send new articles to John Snow from a specific email address"
	echo "  ${SCRIPT_NAME} 'John Snow <john.snow@example.com>' ${SCRIPT_NAME}@example.com  Send new articles to John Snow with his full name and from a specific email address"
	echo "  ${SCRIPT_NAME} -q john.snow@example.com ${SCRIPT_NAME}@example.com             Run in quiet mode"
	echo ""
	echo "Report bugs to <${SCRIPT_URI}>."
}

f2e_log()
{
	local log_level="$1"
	local log_msg="$2"
	local do_print_stderr="-s"

	case "${log_level}" in
		err|warn|notice)
			;;
		*)
			[ ${f2e_is_quiet} -eq 1 ] && do_print_stderr=""
			;;
	esac
	logger ${do_print_stderr} -t "${SCRIPT_NAME}" -p ${F2E_LOG_FACILITY}.${log_level} "${log_msg}"
}

# compute a (probably) unique hash
f2e_hash()
{
	local data="$1"
	echo -en "${data}" | md5sum | awk '{ printf $1 }'
	return $?
}

# strip empty lines but also spaces at the beginning and end of the given string
f2e_trim()
{
	echo -en "$1" | sed -e 's/^ *//' -e 's/ *$//' | grep -vE '^$'
	return $?
}

# pretty print the modification date of the given file
f2e_mdate()
{
	local file="$1"
	local timestamp="$( stat --format="%Y" "${file}" )"
	date --date="@${timestamp}" | awk '{ printf $0 }'
}

# get feed URI from a line in the feed list
f2e_get_feed_uri_from_list_line()
{
	local feed_line="$1"
	echo -n "${feed_line}" | awk '{ printf $1 }' | sed -e 's/#//'
}

# get feed flags from a line in the feed list
f2e_get_feed_flags_from_list_line()
{
	local feed_line="$1"
	echo -n "${feed_line}" | awk '{ printf $2 }'
}

# whether the given feed is registered or not
# return 0 if registered, 1 if not
f2e_is_feed_registered()
{
	local feed_uri="$1"
	grep -q "^#\?${feed_uri}\( \+.*\)\?$" "${F2E_FEEDLIST_FILE}"
	return $?
}

# whether the given feed is disabled or not
# return 0 if disabled, 1 if not
f2e_is_feed_disabled()
{
	local feed_uri="$1"
	grep -q "^#${feed_uri}\( \+.*\)\?$" "${F2E_FEEDLIST_FILE}"
	return $?
}

# whether the given line in the feed list is disabled or not
# return 0 if disabled, 1 if not
f2e_is_feed_line_disabled()
{
	local feed_line="$1"
	echo -n "${feed_line}" | grep -q "^#"
	return $?
}

# get feed flags for the given feed URI
f2e_get_feed_flags()
{
	local feed_uri="$1"
	grep "^#\?${feed_uri}\( \+.*\)\?$" "${F2E_FEEDLIST_FILE}" | awk '{ printf $2 }'
}

# whether the given flag is enabled or not
# return 0 if enabled, 1 if not
f2e_is_feed_flag_enabled()
{
	local feed_flags="$1"
	local feed_flag="$2"
	echo -n "${feed_flags}" | grep -q "\(^${feed_flag}$\|^${feed_flag},\|,${feed_flag},\|,${feed_flag}$\)"
	return $?
}

# print current configuration or configure
f2e_config()
{
	local config_attr="$1"
	local config_val="$2"

	if [ -z "${config_attr}" ] ; then

		# print all configuration attributes
		echo "configuration:"
		for config_attr in email-to email-from fake-user-agent ; do
			echo "  ${config_attr} = $( cat "${F2E_CONFIG_DIR}/${config_attr}" 2>/dev/null )"
		done

		return 0

	else

		# reject unknown attributes
		case "${config_attr}" in
			email-to|email-from|fake-user-agent)
				;;
			*)
				echo "unknown config attribute '${config_attr}'" >&2
				return 1
		esac

		# print or configure?
		if [ -z "${config_val}" ] ; then
			if [ ! -f "${F2E_CONFIG_DIR}/${config_attr}" ] ; then
				echo "attribute '${config_attr}' not configured yet" >&2
				return 1
			fi
			cat "${F2E_CONFIG_DIR}/${config_attr}" ; echo
			return $?
		else
			echo -n "${config_val}" > "${F2E_CONFIG_DIR}/${config_attr}"
			return $?
		fi
	fi
}

# list the registered feeds
f2e_feeds_list()
{
	local feeds_max_nr=$( wc -l < "${F2E_FEEDLIST_FILE}" )
	local feeds_nr
	local feed_info

	echo "${feeds_max_nr} registered feeds:"
	feeds_nr=1
	while read feed_info ; do
		local feed_title
		local feed_uri
		local feed_flags
		local feed_hash
		local feed_dir

		feed_uri="$( f2e_get_feed_uri_from_list_line "${feed_info}" )"
		feed_flags="$( f2e_get_feed_flags_from_list_line "${feed_info}" )"

		# compute a (probably) unique hash for the feed
		feed_hash="$( f2e_hash "${feed_uri}" )"
		ret=$?
		if [ ${ret} -ne 0 ] ; then
			f2e_log "err" "failed to compute hash for feed '${feed_uri}' (${ret})"
			feeds_nr=$(( ${feeds_nr} + 1 ))
			continue
		fi

		# compute feed directory and title
		feed_dir="${F2E_FEEDS_DIR}/${feed_hash}/"
		feed_title="$( cat "${feed_dir}/title" 2>/dev/null )"

		printf "%3d: [" ${feeds_nr}
		f2e_is_feed_line_disabled "${feed_info}"
		if [ $? -eq 0 ] ; then
			echo -n " "
		else
			echo -n "*"
		fi
		echo -n "] "
		if [ -z "${feed_title}" ] ; then
			echo -n "---"
		else
			echo -n "${feed_title}"
		fi
		echo -n " (${feed_uri})"
		if [ -n "${feed_flags}" ] ; then
			echo -n " [${feed_flags}]"
		fi
		echo

		feeds_nr=$(( ${feeds_nr} + 1 ))

	done < "${F2E_FEEDLIST_FILE}"
}

# register a new feed
f2e_feed_add()
{
	local feed_uri="$1"
	local feed_flags="$2"

	f2e_is_feed_registered "${feed_uri}"
	if [ $? -eq 0 ] ; then
		echo "cannot add feed '${feed_uri}', feed is already registered" >&2
		return 1
	fi

	echo "${feed_uri} ${feed_flags}" >> "${F2E_FEEDLIST_FILE}"
	ret=$?
	if [ ${ret} -ne 0 ] ; then
		echo "cannot add feed '${feed_uri}' (${ret})"
		return ${ret}
	fi
	echo "feed '${feed_uri}' added"

	return ${ret}
}

# delete an existing feed
f2e_feed_del()
{
	local feed_uri="$1"

	f2e_is_feed_registered "${feed_uri}"
	if [ $? -ne 0 ] ; then
		echo "cannot remove feed '${feed_uri}', feed is not registered" >&2
		return 1
	fi

	grep -v "^#\?${feed_uri}\( \+.*\)\?$" "${F2E_FEEDLIST_FILE}" > "${F2E_TMP_FILE}"
	ret=$?
	if [ ${ret} -eq 0 ] ; then
		mv -f "${F2E_TMP_FILE}" "${F2E_FEEDLIST_FILE}"
		ret=$?
	fi
	if [ ${ret} -ne 0 ] ; then
		echo "cannot delete feed '${feed_uri}' (${ret})"
		return ${ret}
	fi
	echo "feed '${feed_uri}' deleted"

	return ${ret}
}

# print the status of all feeds in error or of an existing feed
f2e_feed_print_status()
{
	local feed_uri="$1"
	local feed_status
	local feed_hash
	local feed_dir
	local feed_title

	if [ -z "${feed_uri}" ] ; then

		# print the status of all feeds in error for quick diagnostic

		local not_retrieved=""
		local stderr_list=""
		local stderr_file
		local http_ok_list=""
		local http_file

		# feeds not yet retrieved are suspicious
		not_retrieved="$( grep -vE "^#" "${F2E_FEEDLIST_FILE}" )"

		# feeds for which curl output something on stderr are suspicious
		for stderr_file in $( find "${F2E_FEEDS_DIR}" -name feed.xml.stderr -and -not -size 0c ) ; do
			stderr_list="${stderr_list}$( cat "$( dirname "${stderr_file}" )/uri" )\n"
		done

		# feeds with HTTP status codes different than 200 or 304 are suspicious
		for http_file in $( find "${F2E_FEEDS_DIR}" -name feed.xml.headers ) ; do
			local http_code="$( head -n 1 "${http_file}" | awk '{ printf $2 }' )"
			case "${http_code}" in
				200|304)
					;;
				*)
					http_ok_list="${http_ok_list}$( cat "$( dirname "${feed_dir}" )/uri" )\n"
					;;
			esac
		done

		local feed_uris="$( echo -e "${not_retrieved}${stderr_list}${http_ok_list}" | sort | uniq )"
		local feeds_nr=1
		for feed_uri in $( echo -e "${feed_uris}" ) ; do
			printf "%3d: " ${feeds_nr}
			echo "${feed_uri}:"
			echo -e "${not_retrieved}" | grep -q "^${feed_uri}$" && \
				echo "     * not retrieved yet"
			echo -e "${stderr_list}" | grep -q "^${feed_uri}$" && \
				echo "     * download issued errors: $( cat ${F2E_FEEDS_DIR}/$( f2e_hash "${feed_uri}" )/feed.xml.stderr )"
			echo -e "${http_ok_list}" | grep -q "^${feed_uri}$" && \
				echo "     * download issued HTTP code $( head -n 1 ${F2E_FEEDS_DIR}/$( f2e_hash "${feed_uri}" )/feed.xml.headers | awk '{ printf $2 }' )"
			feeds_nr=$(( ${feeds_nr} + 1 ))
		done

	else

		# print the status of an existing feed

		local feed_flags

		f2e_is_feed_registered "${feed_uri}"
		if [ $? -ne 0 ] ; then
			echo "cannot print status of feed '${feed_uri}', feed is not registered" >&2
			return 1
		fi

		f2e_is_feed_disabled "${feed_uri}"
		if [ $? -eq 0 ] ; then
			feed_status="disabled"
		else
			feed_status="enabled"
		fi

		feed_flags="$( grep "^#\?${feed_uri}" "${F2E_FEEDLIST_FILE}" | gawk '{ print $2 }' )"
		feed_hash="$( f2e_hash "${feed_uri}" )"
		feed_dir="${F2E_FEEDS_DIR}/${feed_hash}/"

		echo "feed '${feed_uri}':"

		if [ ! -d "${feed_dir}" ] || [ ! -f "${feed_dir}/title" ] ; then
			echo "  status.......... ${feed_status} / not retrieved yet"
			echo "  flags........... ${feed_flags}"
		else
			feed_title="$( cat "${feed_dir}/title" )"
			articles_nr="$( \ls -1 ${feed_dir}/items/all/* 2>/dev/null | wc -l )"
			new_articles_nr="$( \ls -1 ${feed_dir}/items/new/* 2>/dev/null | wc -l )"
			echo "  status.......... ${feed_status} / retrieved"
			echo "  title........... ${feed_title}"
			echo "  articles........ ${articles_nr} (with ${new_articles_nr} new)"
			echo "  last fetch...... $( f2e_mdate "${feed_dir}/feed.xml.headers" )"
			echo "  last change..... $( f2e_mdate "${feed_dir}/feed.xml" )"
			echo "  flags........... ${feed_flags}"
			echo "  hash............ ${feed_hash}"
			echo "  directory....... ${feed_dir}"
			echo "  HTTP status..... $( head -n 1 "${feed_dir}/feed.xml.headers" )"
			[ -f "${feed_dir}/feed.xml.last_modified" ] && \
			echo "  Last-Modified... $( cat "${feed_dir}/feed.xml.last_modified" )"
			[ -f "${feed_dir}/feed.xml.etag" ] && \
			echo "  ETag............ $( cat "${feed_dir}/feed.xml.etag" )"
		fi

	fi

	return 0
}

# enable an existing feed
f2e_feed_enable()
{
	local feed_uri="$1"

	f2e_is_feed_registered "${feed_uri}"
	if [ $? -ne 0 ] ; then
		echo "cannot enable feed '${feed_uri}', feed is not registered" >&2
		return 1
	fi

	f2e_is_feed_disabled "${feed_uri}"
	if [ $? -ne 0 ] ; then
		echo "cannot enable feed '${feed_uri}', feed is already enabled" >&2
		return 1
	fi

	sed -i -e "s|^#${feed_uri}\( \+.*\)\?$|${feed_uri}\1|" "${F2E_FEEDLIST_FILE}"
	ret=$?
	if [ ${ret} -ne 0 ] ; then
		echo "cannot enable feed '${feed_uri}' (${ret})"
		return ${ret}
	fi
	echo "feed '${feed_uri}' enabled"

	return ${ret}
}

# disable an existing feed
f2e_feed_disable()
{
	local feed_uri="$1"

	f2e_is_feed_registered "${feed_uri}"
	if [ $? -ne 0 ] ; then
		echo "cannot disable feed '${feed_uri}', feed is not registered" >&2
		return 1
	fi

	f2e_is_feed_disabled "${feed_uri}"
	if [ $? -eq 0 ] ; then
		echo "cannot disable feed '${feed_uri}', feed is already disabled" >&2
		return 1
	fi

	sed -i -e "s|^${feed_uri}\( \+.*\)\?$|\#${feed_uri}\1|" "${F2E_FEEDLIST_FILE}"
	ret=$?
	if [ ${ret} -ne 0 ] ; then
		echo "cannot disable feed '${feed_uri}' (${ret})"
		return ${ret}
	fi
	echo "feed '${feed_uri}' disabled"

	return ${ret}
}

# download the given URI to the given local file
# return 0 in case of success, 1 in case of failure, 2 in case content didn't change
f2e_feed_download()
{
	local feed_uri="$1"
	local feed_output_file="$2"
	local feed_flags="$3"
	local user_agent="${F2E_USER_AGENT}"
	local feed_last_modified
	local feed_etag

	f2e_is_feed_flag_enabled "${feed_flags}" "fake-user-agent"
	if [ $? -eq 0 ] ; then
		if [ -z "${F2E_FAKE_USER_AGENT}" ] ; then
			f2e_log "notice" "HTTP fake user agent requested for feed '${feed_uri}', but it is not defined yet"
			f2e_log "notice" "fix the problem with:"
			f2e_log "notice" "  ${SCRIPT_NAME} config fake-user-agent '<string>'"
		else
			user_agent="${F2E_FAKE_USER_AGENT}"
		fi
	fi

	if [ -f "${feed_output_file}.last_modified" ] ; then
		feed_last_modified=" $( cat "${feed_output_file}.last_modified" )"
	else
		feed_last_modified=""
	fi

	if [ -f "${feed_output_file}.etag" ] ; then
		feed_etag=" $( cat "${feed_output_file}.etag" )"
	else
		feed_etag=""
	fi

	# download the feed (only if server says that it changed)
	curl --silent \
	     --proto -all,https,+http \
	     --compressed \
	     --location \
	     --user-agent "${user_agent}" \
	     --referer "${SCRIPT_URI}" \
	     --header "If-Modified-Since:${feed_last_modified}" \
	     --header "If-None-Match:${feed_etag}" \
	     --retry ${F2E_NETWORK_TRIES} \
	     --max-time ${F2E_NETWORK_TIMEOUT} \
	     --max-filesize ${F2E_NETWORK_MAX_FILE_SIZE} \
	     --dump-header "${feed_output_file}.headers" \
	     --stderr "${feed_output_file}.stderr" \
	     --output "${feed_output_file}" \
	     "${feed_uri}"
	ret=$?

	# print a detailled message in case of failure
	if [ ${ret} -ne 0 ] ; then
		local msg
		if [ ${ret} -eq 6 ] ; then
			msg="Couldn't resolve host. The given remote host was not resolved."
		elif [ ${ret} -eq 7 ] ; then
			msg="Failed to connect to host."
		elif [ ${ret} -eq 28 ] ; then
			msg="Operation timeout. The specified time-out period was reached according to the conditions."
		elif [ ${ret} -eq 35 ] ; then
			msg="SSL connect error. The SSL handshaking failed."
		elif [ ${ret} -eq 51 ] ; then
			msg="The peer's SSL certificate or SSH MD5 fingerprint was not OK."
		elif [ ${ret} -eq 52 ] ; then
			msg="The server didn't reply anything, which here is considered an error."
		elif [ ${ret} -eq 60 ] ; then
			msg="Peer certificate cannot be authenticated with known CA certificates."
		elif [ ${ret} -eq 61 ] ; then
			msg="Unrecognized transfer encoding."
		elif [ ${ret} -eq 63 ] ; then
			msg="Maximum file size exceeded."
		else
			msg="no description yet"
		fi
		f2e_log "notice" "failed to download feed '${feed_uri}': ${msg} (${ret})"
		return 1
	fi

	# curl returns 0 even if the feed wasn't retrieved successfully (for example
	# 403 Forbidden code), so retrieve the exact HTTP status code
	local http_code="$( head -n 1 "${feed_output_file}.headers" | awk '{ printf $2 }' )"
	case "${http_code}" in
		200)
			# OK, continue
			;;
		304)
			# Not Modified, return that parsing shall be skip
			return 2
			;;
		*)
			# other codes, return error
			local http_status="$( head -n 1 "${feed_output_file}.headers" | tr -d '\r\n' )"
			f2e_log "notice" "failed to download feed '${feed_uri}': received '${http_status}'"
			return 1
			;;
	esac

	# in case of 200 OK, record the Last-Modified and ETag headers
	# it will eventually save us some download/parsing next time
	feed_last_modified="$( grep -E "^Last-Modified: " "${feed_output_file}.headers" | \
	                       tail -n 1 | \
	                       awk '{ $1="" ; print $0 }' | \
	                       sed -e 's/^ *//' | \
	                       tr -d '\r' )"
	if [ -z "${feed_last_modified}" ] ; then
		rm -f "${feed_output_file}.last_modified"
	else
		echo -n "${feed_last_modified}" > "${feed_output_file}.last_modified"
	fi
	feed_etag="$( grep -E "^ETag: " "${feed_output_file}.headers" | \
	              tail -n 1 | \
	              awk '{ $1="" ; print $0 }' | \
	              sed -e 's/^ *//' | \
	              tr -d '\r' )"
	if [ -z "${feed_etag}" ] ; then
		rm -f "${feed_output_file}.etag"
	else
		echo -n "${feed_etag}" > "${feed_output_file}.etag"
	fi

	return 0
}

# get one single feed
f2e_get_one_feed()
{
	local feeds_max_nr=$1
	local feeds_nr=$2
	local feed_uri="$3"
	local feed_flags="$4"

	local feed_uri
	local feed_flags
	local feed_type="unknown"
	local feed_title
	local feed_hash
	local feed_dir
	local feed_file
	local feed_line
	local feed_item_content
	local feed_item_title

	f2e_log "info" "* [${feeds_nr}/${feeds_max_nr}] ${feed_uri}"

	# compute a (probably) unique hash for the feed
	feed_hash="$( f2e_hash "${feed_uri}" )"
	ret=$?
	if [ ${ret} -ne 0 ] ; then
		f2e_log "err" "failed to compute hash for feed '${feed_uri}' (${ret})"
		return 1
	fi
	feed_dir="${F2E_FEEDS_DIR}/${feed_hash}/"

	mkdir -p "${feed_dir}"
	echo "${feed_uri}" > "${feed_dir}/uri"

	# download the feed content
	feed_file="${feed_dir}/feed.xml"
	f2e_feed_download "${feed_uri}" "${feed_file}" "${feed_flags}"
	ret=$?
	if [ ${ret} -eq 2 ] ; then
		f2e_log "info" "feed '${feed_uri}' didn't change, nothing new to parse"
		return 0
	elif [ ${ret} -ne 0 ] ; then
		f2e_log "notice" "failed to download feed '${feed_uri}' (${ret})"
		return 1
	fi

	# detect feed type among RSS, Atom and RDF
	# try RSS first...
	feed_title="$( xmlstarlet sel -t -m "/rss/channel" -v "title" < "${feed_file}" )"
	if [ $? -eq 0 ] && [ -n "${feed_title}" ] ; then
		# RSS with encoded content or not?
		local tmp="$( xmlstarlet sel \
		              -N content="http://purl.org/rss/1.0/modules/content/" \
		              -t -m "/rss/channel/item" -v "content:encoded" \
		              < "${feed_file}" )"
		if [ $? -eq 0 ] && [ -n "${tmp}" ] ; then
			feed_type="RSS encoded"
		else
			feed_type="RSS"
		fi
		unset tmp
	else
		# maybe Atom?
		feed_title="$( xmlstarlet sel -N x="http://www.w3.org/2005/Atom" \
		               -t -m "/x:feed" -v "x:title" < "${feed_file}" )"
		if [ $? -eq 0 ] ; then
			feed_type="Atom"
		else
			# maybe RDF?
			feed_title="$( xmlstarlet sel \
			               -N x="http://purl.org/rss/1.0/" \
			               -N rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" \
			               -t -m "/rdf:RDF/x:channel" -v "x:title" < "${feed_file}" )"
			if [ $? -eq 0 ] ; then
				feed_type="RDF"
			fi
		fi
	fi

	# write title in the cache for later use
	echo "${feed_title}" > "${feed_dir}/title"
	# print it on console for info
	f2e_log "info" "  ${feed_title} [${feed_type}]"

	# parse feed items/entries
	if [ "${feed_type}" = "RSS" ] ; then
		xmlstarlet sel \
			-t -m "/rss/channel/item" \
			-v "title" -n \
			-o ${SEP_FIELDS} -n \
			-v "link" -n \
			-o ${SEP_FIELDS} -n \
			-v "description" -n \
			-o ${SEP_ITEMS} -n \
			< "${feed_file}" \
			| xmlstarlet unesc \
			> "${F2E_TMP_FILE}"
	elif [ "${feed_type}" = "RSS encoded" ] ; then
		xmlstarlet sel \
		   -N content="http://purl.org/rss/1.0/modules/content/" \
			-t -m "/rss/channel/item" \
			-v "title" -n \
			-o ${SEP_FIELDS} -n \
			-v "link" -n \
			-o ${SEP_FIELDS} -n \
			-v "content:encoded" -n \
			-o ${SEP_ITEMS} -n \
			< "${feed_file}" \
			| xmlstarlet unesc \
			> "${F2E_TMP_FILE}"
	elif [ "${feed_type}" = "Atom" ] ; then
		xmlstarlet sel \
			-N x="http://www.w3.org/2005/Atom" \
			-t -m "/x:feed/x:entry" \
			-v "x:title" -n \
			-o ${SEP_FIELDS} -n \
			-v "x:link/@href" -n \
			-o ${SEP_FIELDS} -n \
			-v "x:content" -n \
			-o ${SEP_ITEMS} -n \
			< "${feed_file}" \
			| xmlstarlet unesc \
			> "${F2E_TMP_FILE}"
	elif [ "${feed_type}" = "RDF" ] ; then
		xmlstarlet sel \
			-N x="http://purl.org/rss/1.0/" \
			-N rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" \
			-t -m "/rdf:RDF/x:item" \
			-v "x:title" -n \
			-o ${SEP_FIELDS} -n \
			-v "x:link" -n \
			-o ${SEP_FIELDS} -n \
			-v "x:description" -n \
			-o ${SEP_ITEMS} -n \
			< "${feed_file}" \
			| xmlstarlet unesc \
			> "${F2E_TMP_FILE}"
	else
		f2e_log "notice" "feed '${feed_uri}' is neither RSS, Atom nor RDF, ignore it"
		feeds_nr=$(( ${feeds_nr} + 1 ))
		return 1
	fi

	# create one cache file per item/entry
	mkdir -p "${feed_dir}/items/all"
	mkdir -p "${feed_dir}/items/new"
	feed_item_content=""
	feed_item_title=""
	while read feed_line ; do
		if [ "${feed_line}" != "${SEP_ITEMS}" ] ; then
			[ -z "${feed_item_title}" ] && feed_item_title="${feed_line}"
			feed_item_content="${feed_item_content}${feed_line}\n"
		else
			local feed_item_hash="$( f2e_hash "${feed_item_content}" )"
			if [ -f "${feed_dir}/items/all/${feed_item_hash}" ] ; then
				f2e_log "info" "  * old item '${feed_item_title}'"
			else
				f2e_log "info" "  * new item '${feed_item_title}'"
				# record new item in cache
				echo -e "${feed_item_content}" > "${feed_dir}/items/all/${feed_item_hash}"
				ln -snf "../all/${feed_item_hash}" \
				        "${feed_dir}/items/new/${feed_item_hash}"
			fi
			feed_item_title=""
			feed_item_content=""
		fi
	done < "${F2E_TMP_FILE}"

	return 0
}

f2e_get_feeds()
{
	local scope="$1"
	local status=0

	if [ -z "${scope}" ] ; then

		local feeds_max_nr=$( wc -l < "${F2E_FEEDLIST_FILE}" )
		local feeds_nr
		local feed_info

		f2e_log "info" "downloading all ${feeds_max_nr} feeds:"
		feeds_nr=1
		while read feed_info ; do
			local feed_uri="$( f2e_get_feed_uri_from_list_line "${feed_info}" )"
			local feed_flags="$( f2e_get_feed_flags_from_list_line "${feed_info}" )"

			# skip feed if disabled
			f2e_is_feed_line_disabled "${feed_info}"
			if [ $? -eq 0 ] ; then
				f2e_log "info" "* [${feeds_nr}/${feeds_max_nr}] ${feed_uri} [skip]"
			else
				f2e_get_one_feed ${feeds_max_nr} ${feeds_nr} "${feed_uri}" "${feed_flags}"
				status=$(( ${status} + $? ))
			fi
			feeds_nr=$(( ${feeds_nr} + 1 ))
		done < "${F2E_FEEDLIST_FILE}"

	else

		f2e_is_feed_registered "${scope}"
		if [ $? -ne 0 ] ; then
			echo "cannot update feed '${scope}', feed is not registered" >&2
			return 1
		fi

		f2e_is_feed_disabled "${scope}"
		if [ $? -eq 0 ] ; then
			echo "cannot update feed '${scope}', feed is disabled" >&2
			return 1
		fi

		f2e_log "info" "downloading feed '${scope}':"
		f2e_get_one_feed 1 1 "${scope}" "$( f2e_get_feed_flags "${scope}" )"
		status=$(( ${status} + $? ))

	fi

	return ${status}
}

f2e_utf8encode()
{
	echo -e "=?utf-8?B?$( echo -e "${1}" | base64 --wrap=0 )?="
}

f2e_send_email()
{
	local from_name="$1"
	local from_email="$2"
	local feed_uri="$3"
	local feed_hash="$( f2e_hash "${feed_uri}" )"
	local subject="$4"
	local body="$5"
	local to_email="$6"
	echo -e "${body}" | base64 | \
		mail -s "$( f2e_utf8encode "${subject}" )" \
		     -a "From: $( f2e_utf8encode "${from_name}" ) <${from_email}>" \
		     -a "User-Agent: ${F2E_USER_AGENT}" \
		     -a "Content-Type: text/plain; charset=\"utf-8\"" \
		     -a "Content-Transfer-Encoding: base64" \
		     -a "Content-Disposition: inline" \
		     -a "X-RSS-Feed: ${feed_uri}" \
		     -a "X-RSS-Feed-Hash: ${feed_hash}" \
		     -a "X-Rss: 1" \
		     "${to_email}"
	return $?
}

f2e_send_emails()
{
	local scope="$1"
	local new_feed_items
	local new_feed_item
	local status=0

	f2e_log "info" "checking for new articles"
	new_feed_items="$( \ls -1 ${F2E_FEEDS_DIR}/*/items/new/* 2>/dev/null | sort )"
	for new_feed_item in $( echo -e "${new_feed_items}" ) ; do
		local feed_dir="$( dirname "$( dirname "$( dirname "${new_feed_item}" )" )" )"
		local feed_title="$( cat "${feed_dir}/title" )"
		local feed_uri="$( cat "${feed_dir}/uri" )"
		local feed_item_title=""
		local feed_item_link=""
		local feed_item_content=""
		local parser_state=""

		if [ -n "${scope}" ] && [ "${scope}" != "${feed_uri}" ] ; then
			continue
		fi

		parser_state="in_title"
		while read feed_item_line ; do
			case "${parser_state}" in
				in_title)
					if [ "${feed_item_line}" != "${SEP_FIELDS}" ] ; then
						feed_item_title="${feed_item_title}${feed_item_line}\n"
					else
						parser_state="in_link"
					fi
					;;
				in_link)
					if [ "${feed_item_line}" != "${SEP_FIELDS}" ] ; then
						feed_item_link="${feed_item_link}${feed_item_line}\n"
					else
						parser_state="in_content"
					fi
					;;
				in_content)
					feed_item_content="${feed_item_content}${feed_item_line}\n"
					;;
				*)
					f2e_log "err" "unknown parser state '${parser_state}'"
					exit 1
			esac
		done < "${new_feed_item}"

		# normalize title and link
		feed_item_title="$( f2e_trim "${feed_item_title}" )"
		feed_item_link="$( f2e_trim "${feed_item_link}" )"

		f2e_log "info" "  * ${feed_title}: sending new item '${feed_item_title}'"
		f2e_send_email \
			"${feed_title}" "${F2E_EMAIL_FROM}" \
			"${feed_uri}" \
			"${feed_item_title}" \
			"URL: ${feed_item_link}\n\n$( echo -e "${feed_item_content}" | pyhtml2text --body-width=100 )\n\nURL: ${feed_item_link}" \
			"${F2E_EMAIL_TO}"
		ret=$?
		if [ ${ret} -ne 0 ] ; then
			f2e_log "err" "failed to send email to '${F2E_EMAIL_TO}' (${ret})"
		else
			test -h "${new_feed_item}" && rm -f "${new_feed_item}"
		fi
		status=$(( ${status} + ${ret} ))

	done

	return ${status}
}


# parse arguments
f2e_is_quiet=0
while true ; do
	case "$1" in
		-h|--help)
			f2e_print_usage
			exit 1
			;;
		-q|--quiet)
			f2e_is_quiet=1
			shift
			continue
			;;
		-v|--version)
			echo "${SCRIPT_NAME} version ${SCRIPT_VERSION}"
			exit 0
			;;
		*)
			break
			;;
	esac
done
f2e_cmd="$1"
shift
expected_args_min_nr=0
expected_args_max_nr=0
case "${f2e_cmd}" in
	list)
		expected_args_min_nr=0
		expected_args_max_nr=0
		;;
	add)
		expected_args_min_nr=1
		expected_args_max_nr=2
		;;
	del|enable|disable)
		expected_args_min_nr=1
		expected_args_max_nr=1
		;;
	status)
		expected_args_min_nr=0
		expected_args_max_nr=1
		;;
	config)
		expected_args_min_nr=0
		expected_args_max_nr=2
		;;
	update)
		expected_args_min_nr=0
		expected_args_max_nr=1
		;;
	*)
		f2e_log "err" "unknown command '${f2e_cmd}'"
		echo "" >&2
		f2e_print_usage
		exit 1
		;;
esac
if [ $# -lt ${expected_args_min_nr} ] ; then
	f2e_log "err" "command '${f2e_cmd}' expects at least ${expected_args_min_nr} arguments, $# given"
	echo "" >&2
	f2e_print_usage
	exit 1
fi
if [ $# -gt ${expected_args_max_nr} ] ; then
	f2e_log "err" "command '${f2e_cmd}' expects at max ${expected_args_max_nr} arguments, $# given"
	echo "" >&2
	f2e_print_usage
	exit 1
fi
case "${f2e_cmd}" in
	config)
		f2e_config_attr="$1"
		f2e_config_val="$2"
		;;
	add)
		f2e_feed_uri="$1"
		f2e_feed_flags="$2"
		;;
	del|status|enable|disable)
		f2e_feed_uri="$1"
		;;
	update)
		f2e_update_scope="$1"
		;;
esac

# better have a home directory
if [ -z "${HOME}" ] ; then
	f2e_log "err" "user is homeless, \$HOME is empty"
	exit 1
fi
if [ ! -e "${HOME}" ] ; then
	f2e_log "err" "user is homeless, \$HOME '${HOME}' does not exist"
	exit 1
fi
if [ ! -d "${HOME}" ] ; then
	f2e_log "err" "user is homeless, \$HOME '${HOME}' is not a directory"
	exit 1
fi

# create config and cache directories if needed
mkdir -p "${F2E_CONFIG_DIR}"
mkdir -p "${F2E_FEEDS_DIR}"

# nothing to do if the list of feeds does not exist or is empty
if [ ! -e "${F2E_FEEDLIST_FILE}" ] || [ ! -s "${F2E_FEEDLIST_FILE}" ] ; then
	f2e_log "notice" "feed list is empty"
	f2e_log "notice" "add one URI per line in '${F2E_FEEDLIST_FILE}'"
	touch "${F2E_FEEDLIST_FILE}"
	exit 0
fi
if [ ! -f "${F2E_FEEDLIST_FILE}" ] ; then
	f2e_log "err" "feed list '${F2E_FEEDLIST_FILE}' is not a regular file"
	exit 1
fi
F2E_EMAIL_FROM="$( cat "${F2E_CONFIG_DIR}/email-from" 2>/dev/null )"
F2E_EMAIL_TO="$( cat "${F2E_CONFIG_DIR}/email-to" 2>/dev/null )"
F2E_FAKE_USER_AGENT="$( cat "${F2E_CONFIG_DIR}/fake-user-agent" 2>/dev/null )"

# create a secure temporary file
F2E_TMP_FILE="$( mktemp --tmpdir "feeds2email.tmp.XXXXXXXXXX" )"
ret=$?
if [ ${ret} -ne 0 ] ; then
	f2e_log "err" "failed to create a temporary file: mktemp exited with code ${ret}"
	exit 1
fi

# perform required action
case "${f2e_cmd}" in
	config)
		# print current configuration or configure
		f2e_config "${f2e_config_attr}" "${f2e_config_val}"
		status=$?
		;;
	list)
		# list the registered feeds
		f2e_feeds_list
		status=$?
		;;
	add)
		# register a new feed
		f2e_feed_add "${f2e_feed_uri}" "${f2e_feed_flags}"
		status=$?
		;;
	del)
		# delete an existing feed
		f2e_feed_del "${f2e_feed_uri}"
		status=$?
		;;
	status)
		# print the status of all feeds in error or of an existing feed
		f2e_feed_print_status "${f2e_feed_uri}"
		status=$?
		;;
	enable)
		# enable an existing feed
		f2e_feed_enable "${f2e_feed_uri}"
		status=$?
		;;
	disable)
		# disable an existing feed
		f2e_feed_disable "${f2e_feed_uri}"
		status=$?
		;;
	update)
		if [ -z "${F2E_EMAIL_FROM}" ] ; then
			echo "invalid configuration: sender email address not defined" >&2
			echo "" >&2
			echo "fix the problem with:" >&2
			echo "  ${SCRIPT_NAME} config email-from <email>" >&2
			echo "" >&2
			status=1
		elif [ -z "${F2E_EMAIL_TO}" ] ; then
			echo "invalid configuration: user name and email address not defined" >&2
			echo "" >&2
			echo "fix the problem with:" >&2
			echo "  ${SCRIPT_NAME} config email-to 'Name <email>'" >&2
			echo "" >&2
			status=1
		else
			# get contents of feeds
			f2e_get_feeds "${f2e_update_scope}"
			status=$?
			# send emails for new ones
			f2e_send_emails "${f2e_update_scope}"
			status=$(( ${status} + $? ))
		fi
		;;
esac

# remove the temporary file
rm -f "${F2E_TMP_FILE}"

exit ${status}

